// создаем функцию-шаблон, которая будет принимать тип данных и значения, далее будет добавлять каждое значение в массив, где уже будет сравнивать тип значения с выбранным типом данных и фильтровать его, если нашлось совпадение. 
const filterByType = (type, ...values) => values.filter(value => typeof value === type),

//создаем функцию, которая будет скрывать лишние блоки с шаблонами результатов
	hideAllResponseBlocks = () => {
		//создаем массив из имеющихся блоков с возможными заголовками-результатами вывода по классу
		const responseBlocksArray = Array.from(document.querySelectorAll('div.dialog__response-block'));
		//перебираем изначально массив и скрываем все блоки
		responseBlocksArray.forEach(block => block.style.display = 'none');
	},
	//создаем функцию-заготовку для отображения правильного блока-результата, на вход которой поступают сам блок, с его сообщением о результате и строка с выводом фактического результата
	showResponseBlock = (blockSelector, msgText, spanSelector) => {
		//вызываем функцию, которая скроет все блоки с результатами по-умолчанию
		hideAllResponseBlocks();
		//получаем на вход блок, который нужно отобразить и присваеваем ему класс display-block
		document.querySelector(blockSelector).style.display = 'block';
		//если на вход поступили блоки с верными или неверными данными, то отображаем строку с этим результатом, если нет, то по умолчанию будет блок с "Пока нечего показать"
		if (spanSelector) {
			document.querySelector(spanSelector).textContent = msgText;
		}
	},
	//создаем заготовки с данными о блоках для отправки в вышеупомянутую функцию

	//собираем данные блока с ошибочными результатами
	showError = msgText => showResponseBlock('.dialog__response-block_error', msgText, '#error'),
	
	//собираем блок с положительными результатами
	showResults = msgText => showResponseBlock('.dialog__response-block_ok', msgText, '#ok'),

	//и блок с данными по-умолчанию
	showNoResults = () => showResponseBlock('.dialog__response-block_no-results'),

	// основной блок, в который будут поступать фактические данные из формы, а именно из меню выбора типа данных и поля ввода данных
	tryFilterByType = (type, values) => {
		//закидываем код в перехвачик ошибок, чтобы при ошибке код отработал и отобразил ошибку с неверными данными
		try {
			//создаем переменную c массивом, которая будет использовать eval для выполнения последующего кода, записанного строкой. В ней вызываем наш первоначальный шаблон, куда передаем наши два типа данных
			const valuesArray = eval(`filterByType('${type}', ${values})`).join(", ");
			//создаем переменную, которая в зависимости от наличия данных в вышеупомянутых данных в массиве будет отображать тот или иной заголовок для вывода данных. 
			const alertMsg = (valuesArray.length) ?
			//Если в массиве есть данные, то код сработает и вызовет функцию showResults, отобразит данные и перечислит их в строке 
				`Данные с типом ${type}: ${valuesArray}` :
				//если на вход поступят данные например [] или {}, то код отобразит отсутствие подобных данных, так как не нашел совпадений с типом данных, имеющихся в выпадающем меню.
				`Отсутствуют данные типа ${type}`;
			showResults(alertMsg);
			//если пользователь введет неправильные данные, например слово, не заключенное в кавычки, то перехватчик отобразит ошибку, с типом ошибки и неверными данными, введенными пользователем
		} catch (e) {
			showError(`Ошибка: ${e}`);
		}
	};
//создаем перевенную с нашей кнопкой фильтрации, получаем ее по id
const filterButton = document.querySelector('#filter-btn');

//создаем функцию, которая будет перехватывать событие нажатия на нашу кнопку фильтрации
filterButton.addEventListener('click', e => {
	//создаем две переменные, с которыми мы будем работать, и от которых будем получать данные о выбранном типе данных и о введенных значениях в поле
	const typeInput = document.querySelector('#type');
	const dataInput = document.querySelector('#data');
//пишем валидацию поля, если оно будет пустым, а пользователь нажал на фильтрацию, то отобразится наше сообщение благодаря setCustomValidity, и вызовется функция showNoResults, где лежит наш блок для отображения по-умолчанию
	if (dataInput.value === '') {
		dataInput.setCustomValidity('Поле не должно быть пустым!');
		showNoResults();
		//если поле не будет пустым, то очищаем setCustomValidity, скидываем действия кнопки по-умолчанию и запускаем наш код tryFilterByType, куда передаем значение выпадающего меню и поля, предварительно удалив пробелы спереди и сзади. (непонятно зачем удалять пробелы у значений выпадающего меню, если туда нельзя добавить свои значения, если только это делается для того, что вдруг добавили в html значение и случайно добавили пробел)
	} else {
		dataInput.setCustomValidity('');
		e.preventDefault();
		tryFilterByType(typeInput.value.trim(), dataInput.value.trim());
	}
});

